

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="../../_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="../../_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>nef.Network &#8212; Nengo 1.4 1.4 documentation</title>
    <link rel="stylesheet" href="../../_static/guzzle.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="nef.SimpleNode" href="SimpleNode.html" />
    <link rel="prev" title="Python" href="../packages.html" />
<link rel="stylesheet" type="text/css" href="../../_static/custom.css">


  
   

  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="SimpleNode.html" title="nef.SimpleNode"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../packages.html" title="Python"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Nengo 1.4 1.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../scripting/index.html" >Scripting</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../scripting/api.html" >API reference</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../packages.html" accesskey="U">Python</a> &#187;</li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar">
        <a href="
    ../../index.html" class="text-logo">Nengo 1.4</a>
        
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <h2>Table Of Contents</h2>
  </div>
  <div class="sidebar-toc">
    
    
      <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../videos/index.html">Video tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">Written tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../demos/index.html">Demos</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../scripting/index.html">Scripting</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../scripting/basics.html">Introduction to scripting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../scripting/ensembles.html">Configuring ensembles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../scripting/simplenodes.html">Adding arbitary code to a model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../scripting/speed.html">Speeding up network creation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../scripting/weights.html">Connection weights</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../scripting/tips.html">Tips and tricks</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../scripting/api.html">API reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../advanced/index.html">Advanced usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nef_algorithm.html">The NEF Algorithm</a></li>
</ul>

    
  </div>
</div>
        
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="../../search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
    </div>
  </div>
        <div id="right-column">
          
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="../../index.html">Docs</a></li>
              
                <li><a href="../../scripting/index.html">Scripting</a></li>
              
                <li><a href="../../scripting/api.html">API reference</a></li>
              
                <li><a href="../packages.html">Python</a></li>
              
              <li>nef.Network</li>
            </ol>
          </div>
          
          <div class="document clearer body">
            
  <div class="section" id="nef-network">
<h1>nef.Network<a class="headerlink" href="#nef-network" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="nef.Network">
<em class="property">class </em><code class="descclassname">nef.</code><code class="descname">Network</code><span class="sig-paren">(</span><em>name</em>, <em>quick=None</em>, <em>seed=None</em>, <em>fixed_seed=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps a Nengo network with a set of helper functions for simplifying the creation of Nengo models.</p>
<p>This system is meant to allow short, concise code to create Nengo models. For example, we can make a
communication channel like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">nef</span>
<span class="n">net</span><span class="o">=</span><span class="n">nef</span><span class="o">.</span><span class="n">Network</span><span class="p">(</span><span class="s1">&#39;Test Network&#39;</span><span class="p">)</span>
<span class="nb">input</span><span class="o">=</span><span class="n">net</span><span class="o">.</span><span class="n">make_input</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">,</span><span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">A</span><span class="o">=</span><span class="n">net</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="n">neurons</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">dimensions</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">B</span><span class="o">=</span><span class="n">net</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="n">neurons</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">dimensions</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">net</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>
<span class="n">net</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
<span class="n">net</span><span class="o">.</span><span class="n">add_to_nengo</span><span class="p">()</span>
</pre></div>
</div>
<p>This will automatically create the necessary origins, terminations,
ensemble factories, and so on needed to create this network.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>string</em><em> or </em><em>NetworkImpl</em>) – If a string, create and wrap a new NetworkImpl with the given <em>name</em>.  
If an existing NetworkImpl, then create a wrapper around that network.</li>
<li><strong>quick</strong> (<em>boolean</em>) – Default setting for the <em>quick</em> parameter in <a class="reference internal" href="#nef.Network.make" title="nef.Network.make"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.make()</span></code></a>.</li>
<li><strong>fixed_seed</strong> (<em>int</em>) – random number seed to use for creating ensembles.  Every ensemble will
use this seed value, resulting in identical neurons in ensembles that
have the same parameters.  By default, setting this parameter will 
enable quick mode.</li>
<li><strong>seed</strong> (<em>int</em>) – random number seed to use for creating ensembles.  This one seed is used only to
start the random generation process, so each neural group created will be
different (unlike the <em>fixed_seed</em> parameter).  By default, setting this 
parameter will enable quick mode.</li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="nef.Network.make">
<code class="descname">make</code><span class="sig-paren">(</span><em>name</em>, <em>neurons</em>, <em>dimensions</em>, <em>tau_rc=0.02</em>, <em>tau_ref=0.002</em>, <em>max_rate=(200</em>, <em>400)</em>, <em>intercept=(-1</em>, <em>1)</em>, <em>radius=1</em>, <em>encoders=None</em>, <em>decoder_noise=0.1</em>, <em>eval_points=None</em>, <em>noise=None</em>, <em>noise_frequency=1000</em>, <em>mode='spike'</em>, <em>add_to_network=True</em>, <em>node_factory=None</em>, <em>decoder_sign=None</em>, <em>seed=None</em>, <em>quick=None</em>, <em>storage_code=''</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.make" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return an ensemble of neurons.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first simple">
<li><strong>name</strong> (<em>string</em>) – name of the ensemble (must be unique)</li>
<li><strong>neurons</strong> (<em>integer</em>) – number of neurons in the ensemble</li>
<li><strong>dimensions</strong> (<em>integer</em>) – number of dimensions to represent</li>
<li><strong>tau_rc</strong> (<em>float</em>) – membrane time constant</li>
<li><strong>tau_ref</strong> (<em>float</em>) – refractory period</li>
<li><strong>max_rate</strong> (<em>tuple</em><em> or </em><em>list</em>) – range for uniform selection of maximum firing rate in Hz (as a 2-tuple)
or a list of maximum rate values to use</li>
<li><strong>intercept</strong> (<em>tuple</em><em> or </em><em>list</em>) – normalized range for uniform selection of tuning curve x-intercept (as 2-tuple)
or a list of intercept values to use  (intercepts are defined with respect to encoders, so an encoder of -1 and intercept of .3 will result in a neuron only active below -.3)</li>
<li><strong>radius</strong> (<em>float</em>) – representational range</li>
<li><strong>encoders</strong> (<em>list</em>) – list of encoder vectors to use (if None, uniform distribution around unit sphere).
The provided encoders will be automatically normalized to unit length.</li>
<li><strong>decoder_noise</strong> (<em>float</em>) – amount of noise to assume when calculating decoders</li>
<li><strong>eval_points</strong> (<em>list</em>) – list of points to do optimization over</li>
<li><strong>noise</strong> (<em>float</em>) – current noise to inject, chosen uniformly from (-noise,noise)</li>
<li><strong>noise_frequency</strong> (<em>float</em>) – sampling rate (how quickly the noise changes)</li>
<li><strong>mode</strong> (<em>string</em>) – simulation mode (‘direct’, ‘rate’, or ‘spike’)</li>
<li><strong>node_factory</strong> (<em>ca.nengo.model.impl.NodeFactory</em>) – a factory to use instead of the default LIF factory
(for creating ensembles with neurons other than LIF)</li>
<li><strong>decoder_sign</strong> (<em>None</em><em>, </em><em>+1</em><em>, or </em><em>-1</em>) – +1 for positive decoders, -1 for negative decoders.  Set to None to allow both.</li>
<li><strong>quick</strong> (<em>boolean</em><em> or </em><em>None</em>) – if True, saves data from a created ensemble and will re-use it in the future
when creating an ensemble with the same parameters as this one.  If None,
uses the Network default setting.  Note: the use of this parameter is
not encouraged any more: use seed=&lt;number&gt; or fixed_seed=&lt;number&gt; in the Network
constructor instead.</li>
<li><strong>seed</strong> (<em>int</em>) – random number seed to use.  Will be passed to both random.seed() and ca.nengo.math.PDFTools.setSeed().
If this is None and the Network was constructed with a seed parameter, a seed will be randomly generated.</li>
<li><strong>storage_code</strong> (<em>string</em>) – an extra parameter to allow different quick files even if all other parameters
are the same</li>
<li><strong>add_to_network</strong> (<em>boolean</em>) – flag to indicate if created ensemble should be added to the network</li>
</ul>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first last">the newly created ensemble</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nef.Network.make_array">
<code class="descname">make_array</code><span class="sig-paren">(</span><em>name</em>, <em>neurons</em>, <em>length</em>, <em>dimensions=1</em>, <em>**args</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.make_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return an array of ensembles.  This acts like a high-dimensional ensemble,
but actually consists of many sub-ensembles, each one representing a separate dimension.
This tends to be much faster to create and can be more accurate than having one huge
high-dimensional ensemble.  However, since the neurons represent different dimensions
separately, we cannot compute nonlinear interactions between those dimensions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>When forming neural connections from an array to another ensemble (or another array),
any specified function to be computed with be computed on each ensemble individually
(with the results concatenated together).  For example, the following code creates
an array and then computes the sum of the squares of each value within it:</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="n">net</span><span class="o">=</span><span class="n">nef</span><span class="o">.</span><span class="n">Network</span><span class="p">(</span><span class="s1">&#39;Squaring Array&#39;</span><span class="p">)</span>
<span class="nb">input</span><span class="o">=</span><span class="n">net</span><span class="o">.</span><span class="n">make_input</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">A</span><span class="o">=</span><span class="n">net</span><span class="o">.</span><span class="n">make_array</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="n">neurons</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">length</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">B</span><span class="o">=</span><span class="n">net</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="n">neurons</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">dimensions</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">net</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">net</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">transform</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">func</span><span class="o">=</span><span class="n">square</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>All of the parameters from <a class="reference internal" href="#nef.Network.make" title="nef.Network.make"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.make()</span></code></a> can also be used.</p>
<dl class="docutils">
<dt>If the <em>storage_code</em> parameter is used, you may use %d (or variants such as</dt>
<dd>%02d) in the storage code, which will be replaced by the index number of
the ensemble in the array.  Thus, <code class="docutils literal"><span class="pre">storage_code='a%02d'</span></code> will become
<code class="docutils literal"><span class="pre">a00</span></code> for the first ensemble, <code class="docutils literal"><span class="pre">a01</span></code> for the second, <code class="docutils literal"><span class="pre">a02</span></code> for the
third, and so on.</dd>
</dl>
<p>If the <em>encoders</em> parameter is used, you can provide either the standard
array of encoders (e.g. <code class="docutils literal"><span class="pre">[[1],[-1]]</span></code>) or a list of sets of encoders for
each ensemble (e.g. <code class="docutils literal"><span class="pre">[[[1]],[[-1]]]</span></code>).</p>
<p>If the <em>dimensions</em> parameter is used, each ensemble represents the specified number of 
dimensions (default value is 1 dimension per ensemble). For example, if length=5 and 
dimensions=2, then a total of 10 dimensions are represented by the network array. 
The index number of the first ensemble’s first dimension is 0, the index of the first 
ensemble’s second dimension is 1, the index of the second ensemble’s first dimension is 
2, and so on.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first simple">
<li><strong>name</strong> (<em>string</em>) – name of the ensemble array (must be unique)</li>
<li><strong>neurons</strong> (<em>integer</em>) – number of neurons in each ensemble</li>
<li><strong>length</strong> (<em>integer</em>) – number of ensembles in the array</li>
<li><strong>dimensions</strong> (<em>integer</em>) – number of dimensions each ensemble represents</li>
</ul>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first last">the newly created <code class="xref py py-class docutils literal"><span class="pre">ca.nengo.model.impl.NetworkArrayImpl</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nef.Network.make_input">
<code class="descname">make_input</code><span class="sig-paren">(</span><em>name</em>, <em>values</em>, <em>zero_after_time=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.make_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a FunctionInput of dimensionality <code class="docutils literal"><span class="pre">len(values)</span></code>
with <em>values</em> as its constants.  Python functions can be provided
instead of fixed values.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first simple">
<li><strong>name</strong> (<em>string</em>) – name of created node</li>
<li><strong>values</strong> (<em>list</em><em>, </em><em>function</em><em>, </em><em>string</em><em>, or </em><em>dict</em>) – numerical values for the function.  If a list, can contain a mixture of
floats and functions (floats are fixed input values, and functions are
called with the current time and must return a single float).  If <em>values</em>
is a function, will be called with the current time and can return either 
a single float or a list of floats.  If a string, will be treated as a
filename of a csv file with the first number in each row indicating
the time and the other numbers giving the value of the function.  If
a dictionary, the keys,value pairs in the dictionary will be treated
as time,value pairs.</li>
<li><strong>zero_after_time</strong> (<em>float</em><em> or </em><em>None</em>) – if not None, any fixed input value will change to 0 after this
amount of time</li>
</ul>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first last">the created FunctionInput</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nef.Network.make_fourier_input">
<code class="descname">make_fourier_input</code><span class="sig-paren">(</span><em>name</em>, <em>dimensions=None</em>, <em>base=1</em>, <em>high=10</em>, <em>power=0.5</em>, <em>seed=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.make_fourier_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a FunctionInput that randomly varies.  The variation is
generated by randomly generating fourier components with frequencies that are multiples
of <code class="docutils literal"><span class="pre">base</span></code> up to <code class="docutils literal"><span class="pre">high</span></code>, and normalized to have an rms power of <code class="docutils literal"><span class="pre">power</span></code>.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first simple">
<li><strong>name</strong> (<em>string</em>) – name of created node</li>
<li><strong>dimensions</strong> (<em>int</em><em> or </em><em>None</em>) – dimensionality of the input.  If None, will default to the
longest of any of the lists given in the other parameters,
or 1 if there are no lists.</li>
<li><strong>base</strong> (<em>float</em><em> or </em><em>list</em>) – fundamental (lowest) frequency for the fourier series.  If a list, will use different
values for each dimension.  Default is 1Hz</li>
<li><strong>high</strong> (<em>float</em><em> or </em><em>list</em>) – maximum frequency for the fourier series.  If a list, will use different
values for each dimension.  Default is 10Hz</li>
<li><strong>power</strong> (<em>float</em><em> or </em><em>list</em>) – RMS power for the random function.  If a list, will use different
values for each dimension.  Default is 0.5</li>
<li><strong>seed</strong> (<em>int</em><em> or </em><em>list</em><em> or </em><em>None.</em>) – random number seed to use.  If a list, will use different
values for each dimension.  If None, a random seed will be chosen.</li>
</ul>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first last">the created FunctionInput</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nef.Network.make_subnetwork">
<code class="descname">make_subnetwork</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.make_subnetwork" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a subnetwork.  Subnetworks are just Network objects that are
inside other Networks, and are useful for keeping a model organized.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>name</strong> (<em>string</em>) – name of created node</dd>
<dt class="field-name">Returns</dt><dd class="field-body">the created Network</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nef.Network.compute_transform">
<code class="descname">compute_transform</code><span class="sig-paren">(</span><em>dim_pre</em>, <em>dim_post</em>, <em>weight=1</em>, <em>index_pre=None</em>, <em>index_post=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.compute_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function used by <a class="reference internal" href="#nef.Network.connect" title="nef.Network.connect"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.connect()</span></code></a> to create a 
<em>dim_pre</em> by <em>dim_post</em> matrix.   All values are either 0 or <em>weight</em>.  
<em>index_pre</em> and <em>index_post</em> are used to determine which values are 
non-zero, and indicate which dimensions of the pre-synaptic ensemble 
should be routed to which dimensions of the post-synaptic ensemble.</p>
<p>For example, with <code class="docutils literal"><span class="pre">dim_pre=2</span></code> and <code class="docutils literal"><span class="pre">dim_post=3</span></code>, 
<code class="docutils literal"><span class="pre">index_pre=[0,1],index_post=[0,1]</span></code> means to take the first two dimensions
of pre and send them to the first two dimensions of post, giving a
transform matrix of <code class="docutils literal"><span class="pre">[[1,0],[0,1],[0,0]]</span></code>
If an index is None, the full range [0,1,2,…,N] is assumed,
so the above example could just be <code class="docutils literal"><span class="pre">index_post=[0,1]</span></code></p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first simple">
<li><strong>dim_pre</strong> (<em>integer</em>) – first dimension of transform matrix</li>
<li><strong>dim_post</strong> (<em>integer</em>) – second dimension of transform matrix</li>
<li><strong>weight</strong> (<em>float</em>) – the non-zero value to put into the matrix</li>
<li><strong>index_pre</strong> (<em>list of integers</em><em> or </em><em>a single integer</em>) – the indexes of the pre-synaptic dimensions to use</li>
<li><strong>index_post</strong> (<em>list of integers</em><em> or </em><em>a single integer</em>) – the indexes of the post-synaptic dimensions to use</li>
</ul>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first last">a two-dimensional transform matrix performing the requested routing</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nef.Network.connect">
<code class="descname">connect</code><span class="sig-paren">(</span><em>pre</em>, <em>post</em>, <em>transform=None</em>, <em>weight=1</em>, <em>index_pre=None</em>, <em>index_post=None</em>, <em>pstc=0.01</em>, <em>func=None</em>, <em>weight_func=None</em>, <em>expose_weights=False</em>, <em>origin_name=None</em>, <em>modulatory=False</em>, <em>plastic_array=False</em>, <em>create_projection=True</em>, <em>encoders=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect two nodes in the network.</p>
<p><em>pre</em> and <em>post</em> can be strings giving the names of the nodes, or they
can be the nodes themselves (FunctionInputs and NEFEnsembles are
supported).  They can also be actual Origins or Terminations, or any
combination of the above. If <em>post</em> is set to an integer or None, an origin
will be created on the <em>pre</em> population, but no other action will be taken.</p>
<p>pstc is the post-synaptic time constant of the new Termination</p>
<p>If transform is not None, it is used as the transformation matrix for
the new termination.  You can also use <em>weight</em>, <em>index_pre</em>, and <em>index_post</em>
to define a transformation matrix instead.  <em>weight</em> gives the value,
and <em>index_pre</em> and <em>index_post</em> identify which dimensions to connect (see
<a class="reference internal" href="#nef.Network.compute_transform" title="nef.Network.compute_transform"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.compute_transform()</span></code></a> for more details).  For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">net</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">weight</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>with both A and B as 2-dimensional ensembles, will use <code class="docutils literal"><span class="pre">[[5,0],[0,5]]</span></code> as
the transform.  Also, you can do:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">net</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">index_pre</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">index_post</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>to connect the 3rd element in A to the 6th in B.  You can also do:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">net</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">index_pre</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">index_post</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
</pre></div>
</div>
<p>to connect multiple elements.</p>
<p>If <em>func</em> is not None, a new Origin will be created on the pre-synaptic
ensemble that will compute the provided function.  The name of this origin 
will taken from the name of the function, or <em>origin_name</em>, if provided.  If an
origin with that name already exists, the existing origin will be used 
rather than creating a new one.</p>
<p><em>func</em> can also be an matrix of values of the same length as the 
<em>eval_points</em> provided to the <em>make</em> function for the <em>pre</em> population.
This uses the data as a lookup table.  For example, we can compute
XOR using the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">net</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">eval_points</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="n">net</span><span class="o">.</span><span class="n">make</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">net</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
<p>If <em>weight_func</em> is not None, the connection will be made using a
synaptic connection weight matrix rather than a DecodedOrigin and
a Decoded Termination.  The computed weight matrix will be passed
to the provided function, which is then free to modify any values in
that matrix, returning a new one that will actually be used.  This
allows for direct control over the connection weights, rather than
just using the once computed via the NEF methods.  If you do not
want to modify these weights, but do want Nengo to compute the weight
matrix, you can just set <em>expose_weights</em> to <code class="docutils literal"><span class="pre">True</span></code>.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first simple">
<li><strong>pre</strong> – The item to connect from.  Can be a string (the name of the
ensemble), an Ensemble (made via <a class="reference internal" href="#nef.Network.make" title="nef.Network.make"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.make()</span></code></a>),
an array of Ensembles (made via <a class="reference internal" href="#nef.Network.make_array" title="nef.Network.make_array"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.make_array()</span></code></a>),
a FunctionInput (made via <a class="reference internal" href="#nef.Network.make_input" title="nef.Network.make_input"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.make_input()</span></code></a>), or
an Origin.</li>
<li><strong>post</strong> – The item to connect to.  Can be a string (the name of the
ensemble), an Ensemble (made via <a class="reference internal" href="#nef.Network.make" title="nef.Network.make"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.make()</span></code></a>),
an array of Ensembles (made via <a class="reference internal" href="#nef.Network.make_array" title="nef.Network.make_array"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.make_array()</span></code></a>),
or a Termination.</li>
<li><strong>transform</strong> (<em>array of floats</em>) – The linear transfom matrix to apply across the connection.
If <em>transform</em> is T and <em>pre</em> represents <code class="docutils literal"><span class="pre">x</span></code>, then the connection
will cause <em>post</em> to represent <code class="docutils literal"><span class="pre">Tx</span></code>.  Should be an N by M array,
where N is the dimensionality of <em>post</em> and M is the dimensionality of <em>pre</em>,
but a 1-dimensional array can be given if either N or M is 1.</li>
<li><strong>pstc</strong> (<em>float</em>) – post-synaptic time constant for the neurotransmitter/receptor implementing
this connection</li>
<li><strong>weight</strong> (<em>float</em>) – scaling factor for a transformation defined with <em>index_pre</em> and <em>index_post</em>.
Ignored if <em>transform</em> is not None.  See <a class="reference internal" href="#nef.Network.compute_transform" title="nef.Network.compute_transform"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.compute_transform()</span></code></a></li>
<li><strong>index_pre</strong> (<em>list of integers</em><em> or </em><em>a single integer</em>) – the indexes of the pre-synaptic dimensions to use.
Ignored if <em>transform</em> is not None.  See <a class="reference internal" href="#nef.Network.compute_transform" title="nef.Network.compute_transform"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.compute_transform()</span></code></a></li>
<li><strong>index_post</strong> (<em>list of integers</em><em> or </em><em>a single integer</em>) – the indexes of the post-synaptic dimensions to use.
Ignored if <em>transform</em> is not None.  See <a class="reference internal" href="#nef.Network.compute_transform" title="nef.Network.compute_transform"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.compute_transform()</span></code></a></li>
<li><strong>func</strong> (<em>function</em>) – <p>function to be computed by this connection.  If None, computes <code class="docutils literal"><span class="pre">f(x)=x</span></code>.
The function takes a single parameter x which is the current value of
the <em>pre</em> ensemble, and must return wither a float or an array of floats.
For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">net</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">func</span><span class="o">=</span><span class="n">square</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">powers</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">^</span><span class="mi">3</span>
<span class="n">net</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">func</span><span class="o">=</span><span class="n">powers</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">net</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">func</span><span class="o">=</span><span class="n">product</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><strong>origin_name</strong> (<em>string</em>) – The name of the origin to create to compute the given function.
Ignored if func is None.  If an origin with this name already
exists, the existing origin is used instead of creating a new one.</li>
<li><strong>weight_func</strong> (<em>function</em><em> or </em><em>None</em>) – if not None, converts the connection to use an explicit connection weight
matrix between each neuron in the ensembles.  This is mathematically
identical to the default method (which simply uses the stored encoders
and decoders for the ensembles), but much slower, since we are no
longer taking advantage of the factorable weight matrix.  However, using
weight_func also allows explicit control over the individual connection
weights, as the computed weight matrix is passed to <em>weight_func</em>, which
can make changes to the matrix before returning it.  If weight_func is
a function taking one argument, it is passed the calculated weight
matrix.  If it is a function taking two arguments, it is passed the
encoder and decoder.</li>
<li><strong>expose_weights</strong> – if True, set <em>weight_func</em> to the identity function.  This makes the
connection use explicit connection weights, but doesn’t modify them
in any way.  Ignored if <em>weight_func</em> is not None.</li>
<li><strong>modulatory</strong> (<em>boolean</em>) – whether the created connection should be marked as modulatory,
meaning that it does not directly affect the input current
to the neurons, but instead may affect internal parameters
in the neuron model.</li>
<li><strong>plastic_array</strong> (<em>boolean</em>) – configure the connection to be learnable.  See <a class="reference internal" href="#nef.Network.learn" title="nef.Network.learn"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.learn()</span></code></a>.</li>
<li><strong>create_projection</strong> (<em>boolean</em>) – flag to disable actual creation of the connection.  If False,
any needed Origin and/or Termination will be created, and the
return value will be the tuple <code class="docutils literal"><span class="pre">(origin,termination)</span></code> rather
than the created projection object.</li>
</ul>
</dd>
<dt class="field-name">Returns</dt><dd class="field-body"><p class="first last">the created Projection, or <code class="docutils literal"><span class="pre">(origin,termination)</span></code> if <em>create_projection</em> is False.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nef.Network.learn">
<code class="descname">learn</code><span class="sig-paren">(</span><em>post</em>, <em>learn_term</em>, <em>mod_term</em>, <em>rate=5e-07</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.learn" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a learning rule to a termination of the <em>post</em> ensemble.
The <em>mod_term</em> termination will be used as an error signal
that modulates the changing connection weights of <em>learn_term</em>.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first last simple">
<li><strong>post</strong> (<em>string</em><em> or </em><em>Ensemble</em>) – the ensemble whose termination will be changing,
or the name of this ensemble</li>
<li><strong>learn_term</strong> (<em>string</em><em> or </em><em>Termination</em>) – the termination whose transform will be
modified by the learning rule.  This termination must be
created with plastic_array=True in <a class="reference internal" href="#nef.Network.connect" title="nef.Network.connect"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.connect()</span></code></a></li>
<li><strong>mod_term</strong> (<em>string</em><em> or </em><em>Termination</em>) – the modulatory input to the learning rule; this is
optional. It will be checked if <cite>learn_term</cite> is
a <cite>ModulatedPlasticEnsembleTermination</cite>,
and not otherwise.</li>
<li><strong>rate</strong> (<em>float</em>) – <p>the learning rate that will be used in the learning
fuctions.</p>
<span class="target" id="index-0"></span><div class="admonition-todo admonition">
<p class="first admonition-title">Todo</p>
<p class="last">(Possible enhancement: make this 2D for stdp
mode, different rates for in_fcn and out_fcn)</p>
</div>
</li>
</ul>
</dd>
</dl>
<p>If <em>stdp</em> is True, a triplet-based spike-timinng-dependent plasticity rule
is used, based on that defined in:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Pfister</span><span class="p">,</span> <span class="n">J</span><span class="o">.</span> <span class="ow">and</span> <span class="n">Gerstner</span><span class="p">,</span> <span class="n">W</span><span class="o">.</span> <span class="p">(</span><span class="mi">2006</span><span class="p">)</span> <span class="n">Triplets</span> <span class="n">of</span> <span class="n">Spikes</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">Model</span> <span class="n">of</span> <span class="n">Spike</span> 
<span class="n">Timing</span><span class="o">-</span><span class="n">Dependent</span> <span class="n">Plasticity</span><span class="o">.</span> <span class="n">J</span><span class="o">.</span> <span class="n">Neurosci</span><span class="o">.</span><span class="p">,</span> <span class="mi">26</span><span class="p">:</span> <span class="mi">9673</span> <span class="o">-</span> <span class="mf">9682.</span>
</pre></div>
</div>
<p>The parameters for this learning rule have the following defaults, and can be
set as keyword arguments to this function call:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">a2Minus</span><span class="o">=</span><span class="mf">5.0e-3</span><span class="p">,</span> <span class="n">a3Minus</span><span class="o">=</span><span class="mf">5.0e-3</span><span class="p">,</span> <span class="n">tauMinus</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span> <span class="n">tauX</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span>
 <span class="n">a2Plus</span><span class="o">=</span><span class="mf">5.0e-3</span><span class="p">,</span>  <span class="n">a3Plus</span><span class="o">=</span><span class="mf">5.0e-3</span><span class="p">,</span> <span class="n">tauPlus</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span> <span class="n">tauY</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span>
 <span class="n">decay</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">homeostatis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>If <em>stdp</em> is False, a rate-mode error minimizing learning rule is applied.
The only parameter available here is whether or not to include an oja
normalization term:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">oja</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nef.Network.learn_array">
<code class="descname">learn_array</code><span class="sig-paren">(</span><em>array</em>, <em>learn_term</em>, <em>mod_term</em>, <em>rate=5e-07</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.learn_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a learning rule to a termination of a <code class="xref py py-class docutils literal"><span class="pre">ca.nengo.model.impl.NetworkArrayImpl</span></code> (an array of
ensembles, created using <a class="reference internal" href="#nef.Network.make_array" title="nef.Network.make_array"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.make_array()</span></code></a>).</p>
<p>See <a class="reference internal" href="#nef.Network.learn" title="nef.Network.learn"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.learn()</span></code></a> for parameters.</p>
</dd></dl>

<dl class="method">
<dt id="nef.Network.add_to_nengo">
<code class="descname">add_to_nengo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.add_to_nengo" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the network to the Nengo user interface.  If there is no user interface
(i.e. if Nengo is being run via the command line only interface <code class="docutils literal"><span class="pre">nengo-cl</span></code>),
then do nothing.</p>
</dd></dl>

<dl class="method">
<dt id="nef.Network.add_to">
<code class="descname">add_to</code><span class="sig-paren">(</span><em>world=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.add_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the network to the given Nengo world object.  If there is a
network with that name already there, remove the old one.  If world is
None, it will attempt to find a running version of Nengo to add to.</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 1.3: </span>Use <a class="reference internal" href="#nef.Network.add_to_nengo" title="nef.Network.add_to_nengo"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.add_to_nengo()</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="nef.Network.view">
<code class="descname">view</code><span class="sig-paren">(</span><em>play=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the interactive mode viewer for running the network</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>play</strong> (<em>False</em><em> or </em><em>float</em>) – Automatically starts the simulation running, stopping after the given amount of time</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nef.Network.set_layout">
<code class="descname">set_layout</code><span class="sig-paren">(</span><em>view</em>, <em>layout</em>, <em>control</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.set_layout" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the graphical layout for the interactive plots</p>
<p>You can use this to specify a particular layout.  This will replace the currently
saved layout (if any).  Useful when running a script on a new computer that does
not have a previously saved layout (saving you from also copying over that layout
file).</p>
<p>The arguments for this function call are generally made by opening up
interacive plots, making the layout you want, saving the layout, and then
copying the text in <code class="docutils literal"><span class="pre">layouts/&lt;networkname&gt;.layout</span></code>.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first last simple">
<li><strong>view</strong> (<em>dictionary</em>) – parameters for the window position</li>
<li><strong>layout</strong> (<em>list</em>) – list of all components to be shown and their parameters</li>
<li><strong>control</strong> (<em>dictionary</em>) – configuration parameters for the simulation</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nef.Network.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the node to the network.</p>
<p>This is generally only used for manually created nodes, not ones created by calling
<a class="reference internal" href="#nef.Network.make" title="nef.Network.make"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.make()</span></code></a> or <a class="reference internal" href="#nef.Network.make_input" title="nef.Network.make_input"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.make_input()</span></code></a> as these are
automatically added.  A common usage is with <a class="reference internal" href="SimpleNode.html#nef.SimpleNode" title="nef.SimpleNode"><code class="xref py py-class docutils literal"><span class="pre">nef.SimpleNode</span></code></a> objects, as
in the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">node</span><span class="o">=</span><span class="n">net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MyNode</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">))</span>
</pre></div>
</div>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>node</strong> – the node to be added</dd>
<dt class="field-name">Returns</dt><dd class="field-body">node</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nef.Network.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove nodes from a network. Either the node object or the node name can
be used as a parameter to this function</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><strong>node</strong> – the node or name of the node to be removed</dd>
<dt class="field-name">Returns</dt><dd class="field-body">node removed</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nef.Network.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>name</em>, <em>default=&lt;type 'exceptions.Exception'&gt;</em>, <em>require_origin=False</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the node with the given <em>name</em> from the network</p>
</dd></dl>

<dl class="method">
<dt id="nef.Network.set_alias">
<code class="descname">set_alias</code><span class="sig-paren">(</span><em>alias</em>, <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.set_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a named shortcut to an existing node within this network to be
used to simplify connect() calls.</p>
<p>For example, you can do:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">net</span><span class="o">.</span><span class="n">set_alias</span><span class="p">(</span><span class="s1">&#39;vision&#39;</span><span class="p">,</span><span class="s1">&#39;A.B.C.D.E&#39;</span><span class="p">)</span>
<span class="n">net</span><span class="o">.</span><span class="n">set_alias</span><span class="p">(</span><span class="s1">&#39;motor&#39;</span><span class="p">,</span><span class="s1">&#39;W.X.Y.Z&#39;</span><span class="p">)</span>
<span class="n">net</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;vision&#39;</span><span class="p">,</span><span class="s1">&#39;motor&#39;</span><span class="p">)</span>            
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="nef.Network.releaseMemory">
<code class="descname">releaseMemory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.releaseMemory" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to release extra memory used by the Network.  Call only after all
connections are made.</p>
</dd></dl>

<dl class="method">
<dt id="nef.Network.getNeuronCount">
<code class="descname">getNeuronCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.getNeuronCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total number of neurons in this network</p>
</dd></dl>

<dl class="method">
<dt id="nef.Network.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>time</em>, <em>dt=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the simulation.</p>
<p>If called twice, the simulation will continue for <em>time</em> more seconds.  To reset
the simulation, call <a class="reference internal" href="#nef.Network.reset" title="nef.Network.reset"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.reset()</span></code></a>.  Typical use cases are to either
simply call it once:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">net</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>or to call it multiple times in a row:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">t</span><span class="o">=</span><span class="mi">0</span>
<span class="n">dt</span><span class="o">=</span><span class="mf">0.1</span>
<span class="k">while</span> <span class="n">t</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">:</span>
   <span class="n">net</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
   <span class="n">t</span><span class="o">+=</span><span class="n">dt</span> 
</pre></div>
</div>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first last simple">
<li><strong>time</strong> (<em>float</em>) – the amount of time (in seconds) to run for</li>
<li><strong>dt</strong> (<em>float</em>) – the size of the time step to use</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nef.Network.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the simulation.</p>
<p>Should be called if you have previously called
<a class="reference internal" href="#nef.Network.run" title="nef.Network.run"><code class="xref py py-func docutils literal"><span class="pre">nef.Network.run()</span></code></a>, but now want to reset the simulation
to its initial state.</p>
</dd></dl>

<dl class="method">
<dt id="nef.Network.log">
<code class="descname">log</code><span class="sig-paren">(</span><em>name=None</em>, <em>dir=None</em>, <em>filename='%(name)s-%(time)s.csv'</em>, <em>interval=0.001</em>, <em>tau=0.01</em>, <em>auto_flush=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a <code class="xref py py-class docutils literal"><span class="pre">nef.Log</span></code> object which dumps data to a .csv file as the model runs.</p>
<p>See the <code class="xref py py-class docutils literal"><span class="pre">nef.Log</span></code> documentation for details.</p>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>string</em>) – The name of the model.  Defaults to the name of the Network object.</li>
<li><strong>dir</strong> (<em>string</em>) – The directory to place the .csv file into</li>
<li><strong>filename</strong> (<em>string</em>) – The filename to use.  <code class="docutils literal"><span class="pre">.csv</span></code> will be added if it is not already
there. Can use <code class="docutils literal"><span class="pre">%(name)s</span></code> to refer to the <em>name</em> of the model
and <code class="docutils literal"><span class="pre">%(time)s</span></code> to refer to the start time of the model.  Defaults
to <code class="docutils literal"><span class="pre">%(name)s-%(time)s.csv</span></code>.</li>
<li><strong>interval</strong> (<em>float</em>) – The time interval between each row of the log.  Defaults to 0.001 (1ms).</li>
<li><strong>tau</strong> (<em>float</em>) – The default filter time for data.  Defaults to 0.01 (10ms).</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nef.Network.set_view_function_1d">
<code class="descname">set_view_function_1d</code><span class="sig-paren">(</span><em>node</em>, <em>basis</em>, <em>label='1D function'</em>, <em>minx=-1</em>, <em>maxx=1</em>, <em>miny=-1</em>, <em>maxy=1</em><span class="sig-paren">)</span><a class="headerlink" href="#nef.Network.set_view_function_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a function representation for the given node.</p>
<p>This has no effect on the model itself, but provides a useful display in the
interactive plots visualizer.  The vector represented by the function is plotted
by treating the vector values as weights for a set of basis functions.  So, if
a vector is (2,0,3) and the basis functions are <span class="math">\(x^2\)</span>, <span class="math">\(x\)</span>, and <span class="math">\(1\)</span>, we get the
polynomial <span class="math">\(2*x^2+3\)</span>.</p>
<p>The provided basis function should accept two parameters: and index value indicating which
basis function should be computed, and x, indicating the x value to compute the basis function at.
For example, for polinomials, the basis functions would be computed as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">polynomial_basis</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
     <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="n">index</span>
</pre></div>
</div>
<dl class="docutils field-list" frame="void" rules="none">
<dt class="field-name">Parameters</dt><dd class="field-body"><ul class="first last simple">
<li><strong>node</strong> (<em>Node</em>) – The Nengo component that represents the vector</li>
<li><strong>basis</strong> (<em>function</em>) – The set of basis functions to use.  This is a single function accepting
two parameters: the basis index and the x value.  It should return the
corresponding y value.</li>
<li><strong>label</strong> (<em>string</em>) – The text that will appear in the pop-up menu to activate this view</li>
<li><strong>minx</strong> (<em>float</em>) – minimum x value to plot</li>
<li><strong>maxx</strong> (<em>float</em>) – maximum x value to plot</li>
<li><strong>miny</strong> (<em>float</em>) – minimum y value to plot</li>
<li><strong>maxy</strong> (<em>float</em>) – maximum y value to plot</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


          </div>
            
  <div class="footer-relations">
    
      <div class="pull-left">
        <a class="btn btn-default" href="../packages.html" title="previous chapter (use the left arrow)">Python</a>
      </div>
    
      <div class="pull-right">
        <a class="btn btn-default" href="SimpleNode.html" title="next chapter (use the right arrow)">nef.SimpleNode</a>
      </div>
    </div>
    <div class="clearer"></div>
  
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="SimpleNode.html" title="nef.SimpleNode"
             >next</a> |</li>
        <li class="right" >
          <a href="../packages.html" title="Python"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Nengo 1.4 1.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../scripting/index.html" >Scripting</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../scripting/api.html" >API reference</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../packages.html" >Python</a> &#187;</li> 
      </ul>
    </div>
  <script type="text/javascript">
    $(document).ready(function() {
      $(".toggle > *").hide();
      $(".toggle .header").show();
      $(".toggle .header").click(function() {
        $(this).parent().children().not(".header").toggle(400);
        $(this).parent().children(".header").toggleClass("open");
      });
    });
  </script>

<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="../../_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 2006-2017, Bryan Tripp & Centre for Theoretical Neuroscience, University of Waterloo. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>